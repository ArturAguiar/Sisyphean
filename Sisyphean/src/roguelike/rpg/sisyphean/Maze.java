package roguelike.rpg.sisyphean;

import sofia.util.Random;

// -------------------------------------------------------------------------
/**
 *  This class represents a Maze as a 2D array of Cell objects.
 *  The size of the maze is dependent upon the floor level the player has
 *  entered, and the layout is randomly generated by removing walls of each cell
 *  according to a randomization of Prim's Algorithm.
 *  The maze also handles the randomized spawning of enemies and items.
 *
 *  @author Petey
 *  @version Nov 4, 2012
 */
public class Maze
{
    private Cell[][] grid;
    private int floor;
    private int size;

    private int startX;
    private int startY;

    private GameWorld gameWorld;

    private Random rand;


    // ----------------------------------------------------------
    /**
     * Create a new Maze object, the size of which is proportional to the floor.
     * @param gameWorld The GameWorld in which the maze is being created
     * @param floor The level of the dungeon the player is traversing
     */
    public Maze(GameWorld gameWorld, int floor)
    {
        this.gameWorld = gameWorld;

        // TODO: Determine size proportionality (for now is floor * 10)
        if (floor < 1)
        {
            grid = new Cell[4][4];
            size = 4;
            this.floor = 1;
        }
        else
        {
            size = floor * 10;
            grid = new Cell[size][size];
            this.floor = floor;
        }
        for (int i = 0; i < grid.length; i++)
        {
            for (int j = 0; j < grid[0].length; j++)
            {
                grid[i][j] = new Cell(i, j);
            }
        }

        rand = new Random();
        generate();
    }


    /**
     * Randomly generates the maze by randomizing the corridors, placing the
     * exit, spawning enemies, and placing items in the maze.
     */
    private void generate()
    {
        primsAlgorithm();
        placeExit();
        spawnEnemies();
        placeItems();
    }

    /**
     * Uses a randomization of Prim's Algorithm to randomly generate the
     * corridors of the maze. See the commented section inside for the steps of
     * the algorithm.
     */
    private void primsAlgorithm()
    {
        // Prim's Algorithm:
        /* Start with the cell at the front of the queue of cells to be further
         * explored (to be checked for adjacent unexplored cells).
         * Find out which adjacent cells are unexplored (those with all 4 walls
         * intact) and store them in a collection.
         * While there are unexplored adjacent cells, pick a random one.
         *      Add the cell to the queue and destroy the wall(s) between the
         *      two cells. Also increase a counter of how many cells have been
         *      explored?
         * Continue until the counter has reached the total number of cells in
         * the maze, or until the queue is empty?
         */

        CellQueue queue = new CellQueue(floor * 10); // Initialize proportional to the floor?
        //RandomGenerator rand = new RandomGenerator();
        Cell[] adjacentCells;

        // Start at a random cell
        Cell currentCell = grid[rand.nextInt(grid.length)][rand.nextInt(grid[0].length)];
        startX = currentCell.x();
        startY = currentCell.y();
        queue.enqueue(currentCell);
        Cell tempCell;

        // Search for unexplored cells until all have been explored
        while (!queue.isEmpty()) //(counter < grid.length * grid[0].length)
        {
            // Add all adjacent cells in a clockwise manner starting from the top.
            // The order of adjacent cells should be: top, right, bottom, left
            adjacentCells = addAdjacentCells(currentCell);
            // Randomly select an adjacent cell.
            // Continue to do so until all adjacent cells have been added to the
            // queue (have been explored).
            int explored = 0;
            //Cell tempCell;
            int index;
            while (explored < adjacentCells.length)
            {
                index = rand.nextInt(adjacentCells.length);
                tempCell = adjacentCells[index];
                // If the cell is not null and still has 4 walls
                if (tempCell != null && tempCell.numberOfWalls() == 4)
                {
                    //Add to the queue
                    queue.enqueue(tempCell);
                    //Remove the corresponding walls and mark as explored
                    currentCell.removeWall(index);
                    if (index + 2 < adjacentCells.length)
                    {
                        tempCell.removeWall(index + 2);
                    }
                    else
                    {
                        tempCell.removeWall(index - 2);
                    }
                }
                explored++;
            }

            //Remove the searched cell from the queue and start over at the next
            // cell.
            queue.dequeue();
            if (!queue.isEmpty())
            {
                currentCell = queue.front();
            }
        }
    }


    /**
     * Adds all cells adjacent to the given cell in a clockwise manner starting
     * from the top and returns them in an array of cells. The order of adjacent
     * cells in this array should be: top, right, bottom, left. If there is no
     * adjacent cell in one of these positions, it will be set to null.
     * @param cell The cell being examined for adjacent cells
     * @return Cell[] The adjacent cells arranged in the predetermined order
     */
    private Cell[] addAdjacentCells(Cell cell)
    {
        Cell[] cells = new Cell[4];

        // Add cell above if it exists
        if (cell.y() - 1 >= 0 && cell.y() - 1 < grid[0].length)
        {
            cells[0] = grid[cell.x()][cell.y() - 1];
        }
        // Add cell to right if it exists
        if (cell.x() + 1 >= 0 && cell.x() + 1 < grid.length)
        {
            cells[1] = grid[cell.x() + 1][cell.y()];
        }
        // Add cell below if it exists
        if (cell.y() + 1 >= 0 && cell.y() + 1 < grid[0].length)
        {
            cells[2] = grid[cell.x()][cell.y() + 1];
        }
        // Add cell to left if it exists
        if (cell.x() - 1 >= 0 && cell.x() - 1 < grid.length)
        {
            cells[3] = grid[cell.x() - 1][cell.y()];
        }

        return cells;
    }

    private void placeExit()
    {
        //TODO: Randomly place the exit in the maze, significantly far away from
        // the start point.
    }

    private void spawnEnemies()
    {
        //TODO: Randomly place enemies on empty cells based on floor level
    }

    private void placeItems()
    {
        //TODO: Randomly place items on empty cells
    }

    // ----------------------------------------------------------
    /**
     * Accessor for the x coordinate of the starting cell.
     * @return int The x coordinate
     */
    public int startX()
    {
        return startX;
    }

    // ----------------------------------------------------------
    /**
     * Accessor for the y coordinate of the starting cell.
     * @return int The y coordinate
     */
    public int startY()
    {
        return startY;
    }

    // ----------------------------------------------------------
    /**
     * Returns the cell at the specified location.
     * @param x The x coordinate of the cell
     * @param y The y coordinate of the cell
     * @return Cell The cell at the given location
     */
    public Cell getCell(int x, int y)
    {
        if (x < grid.length && y < grid[0].length)
        {
            return grid[x][y];
        }
        else
        {
            return null;
        }
    }

    public int size()
    {
        return size;
    }

    // -------------------------------------------------------------------------
    /**
     *  This is a FIFO array-based Queue in which elements are removed in the
     *  order that they were added. This is used in the primsAlgorithm() method
     *  for keeping track of the order in which cells must be examined for
     *  adjacent unexplored cells.
     *
     *  @author Petey
     *  @version Nov 4, 2012
     */
    private class CellQueue
    {
        private Cell[] cells;
        private int capacity;
        private int size;

        /**
         * Creates a new queue of cells of the given capacity.
         * @param capacity The initial capacity of the queue
         */
        public CellQueue(int capacity)
        {
            cells = new Cell[capacity];
            this.capacity = capacity;
        }

        /**
         * Accessor for the number of elements in the queue.
         * @return int The number of elements
         */
        public int size()
        {
            return size;
        }

        /**
         * Accessor for the capacity of the queue.
         * @return int The capacity
         */
        public int capacity()
        {
            return cells.length;
        }

        /**
         * Add the given cell to the back of the queue.
         * @param cell The cell to be appended to the queue
         */
        public void enqueue(Cell cell)
        {
            if (size == capacity)
            {
                expandCapacity();
            }
            cells[size] = cell;
            size++;
        }

        /**
         * Doubles the capacity of the queue.
         */
        private void expandCapacity()
        {
            capacity *= 2;
            Cell[] array = new Cell[capacity];
            System.arraycopy(cells, 0, array, 0, size);
            cells = array;
        }

        /**
         * Remove the first cell in the queue.
         */
        public void dequeue()
        {
            if (size > 0)
            {
                Cell[] array = new Cell[cells.length - 1];
                System.arraycopy(cells, 1, array, 0, size - 1);
                cells = array;
                capacity -= 1;
                size--;
            }
            else
            {
                return;
            }
        }

        /**
         * Accessor for the first cell in the queue.
         * @return Cell The first cell
         */
        public Cell front()
        {
            return cells[0];
        }

        /**
         * Determines whether the queue contains any cells.
         * @return Whether the queue is empty
         */
        public boolean isEmpty()
        {
            return size == 0;
        }

    }

}