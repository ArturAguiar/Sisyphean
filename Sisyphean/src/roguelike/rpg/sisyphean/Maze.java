package roguelike.rpg.sisyphean;

import sofia.util.Random;

// -------------------------------------------------------------------------
/**
 * This class represents a Maze as a 2D array of Cell objects. The size of the
 * maze is dependent upon the floor level the player has entered, and the layout
 * is randomly generated by removing walls of each cell according to a
 * randomization of Prim's Algorithm. The maze also handles the randomized
 * spawning of enemies and items.
 *
 * @author Petey
 * @version Nov 4, 2012
 */
public class Maze
{
    private Cell[][]  grid;
    private int       floor;
    private int       floorSize;

    private int       startX;
    private int       startY;
    private int exitX;
    private int exitY;

    private GameWorld gameWorld;

    private Random    rand;

    private int generations;
    private boolean generated;

    private int counter;

    public String[] itemlist= new String[5];

    // ----------------------------------------------------------
    /**
     * Create a new Maze object, the size of which is proportional to the floor.
     *
     * @param gameWorld
     *            The GameWorld in which the maze is being created
     * @param floor
     *            The level of the dungeon the player is traversing
     */
    public Maze(GameWorld gameWorld, int floor)
    {
        this.gameWorld = gameWorld;

        if (floor < 1) // For testing purposes
        {
            grid = new Cell[4][4];
            floorSize = 4;
            this.floor = 1;
        }
        else
        {
            floorSize = (int)(10 * Math.log(floor + 11) - 14);
            grid = new Cell[floorSize][floorSize];
            this.floor = floor;
        }
        for (int i = 0; i < grid.length; i++)
        {
            for (int j = 0; j < grid[0].length; j++)
            {
                grid[i][j] = new Cell(i, j);
            }
        }

        counter = 0;

        generations = 0;
        generated = false;
        rand = new Random();

        generate();
    }


    /**
     * Randomly generates the maze by randomizing the corridors, placing the
     * exit, spawning enemies, and placing items in the maze.
     */
    private void generate()
    {
        //Generate/regenerate until primsAlgorithm() has successfully
        //generated a maze.
        while (!generated)
        {
            for (Cell[] column : grid)
            {
                for (Cell cell : column)
                {
                    for (int i = 0; i < cell.getWalls().length; i++)
                    {
                        cell.placeWall(i);
                    }
                }
            }
            generated = primsAlgorithm();
        }
        patch();
        openRooms();
        placeExit();
        spawnEnemies();
        placeItems();
    }


    /**
     * Uses a randomization of Prim's Algorithm to randomly generate the
     * corridors of the maze. See the commented section inside for the steps of
     * the algorithm.
     */
    private boolean primsAlgorithm()
    {
        // Prim's Algorithm:
        /*
         * Start with the cell at the front of the queue of cells to be further
         * explored (to be checked for adjacent unexplored cells). Find out
         * which adjacent cells are unexplored (those with all 4 walls intact)
         * and store them in an array. While there are unexplored adjacent
         * cells, pick a random one. Add the cell to the queue and destroy the
         * wall(s) between the two cells. Continue until the queue is empty?
         */

        CellQueue queue = new CellQueue(floorSize ^ 2); // Initialize proportional to the floor?
        Cell[] adjacentCells;

        // Start at a random cell in the bottom row
        Cell currentCell =
            grid[rand.nextInt(grid.length)][grid[0].length - 1];
        startX = currentCell.x();
        startY = currentCell.y();
        queue.enqueue(currentCell);
        Cell tempCell;

        // Search for unexplored cells until all have been explored

        counter = 1;

        while (!queue.isEmpty())
        {
            // Add all adjacent cells in a clockwise manner starting from the
            // top.
            // The order of adjacent cells should be: top, right, bottom, left
            adjacentCells = getAdjacentCells(currentCell);
            // Randomly select an adjacent cell.
            // Continue to do so until all adjacent cells have been added to the
            // queue (have been explored).
            int cellsLeft = 0;
            for (int i = 0; i < adjacentCells.length; i++)
            {
                if (adjacentCells[i] != null)
                {
                    cellsLeft++;
                }
            }
            int index;
            while (cellsLeft > 0)
            {
                index = rand.nextInt(adjacentCells.length); // Find a way to manage randomization more efficiently!
                tempCell = adjacentCells[index];
                // If the cell is not null and still has 4 walls
                if (tempCell != null && tempCell.numberOfWalls() == 4)
                {
                    // Add to the queue
                    queue.enqueue(tempCell);
                    counter++;
                    // Remove the corresponding walls and mark as explored
                    currentCell.removeWall(index);
                    if (index + 2 < adjacentCells.length)
                    {
                        tempCell.removeWall(index + 2);
                    }
                    else
                    {
                        tempCell.removeWall(index - 2);
                    }
                    // cellsLeft--; I think this should fix it, but it doesn't run...
                }
                cellsLeft--; // This is incorrect because it may double count adjacent cells
            }

            // Remove the searched cell from the queue and start over at the
            // next cell.
            queue.dequeue();
            if (!queue.isEmpty())
            {
                currentCell = queue.front();
            }
        }

        // Increase the count of how many times this method has been called.
        generations++;
        // Return true if the maze was generated successfully.
        // A maze is considered successfully generated if more than 90% of the
        // cells are visited by the queue in this algorithm.
        return counter >  ((floorSize * floorSize) * 9 / 10);
    }

/*
    public int counter()
    {
        return counter;
    }
*/

    /**
     * Finds all cells adjacent to the given cell in a clockwise manner starting
     * from the top and returns them in an array of cells. The order of adjacent
     * cells in this array should be: top, right, bottom, left. If there is no
     * adjacent cell in one of these positions, it will be set to null.
     *
     * @param cell
     *            The cell being examined for adjacent cells
     * @return Cell[] The adjacent cells arranged in the predetermined order
     */
    private Cell[] getAdjacentCells(Cell cell)
    {
        Cell[] cells = new Cell[4];

        // Add cell above if it exists
        if (cell.y() - 1 >= 0 && cell.y() - 1 < grid[0].length)
        {
            cells[0] = grid[cell.x()][cell.y() - 1];
        }
        // Add cell to right if it exists
        if (cell.x() + 1 >= 0 && cell.x() + 1 < grid.length)
        {
            cells[1] = grid[cell.x() + 1][cell.y()];
        }
        // Add cell below if it exists
        if (cell.y() + 1 >= 0 && cell.y() + 1 < grid[0].length)
        {
            cells[2] = grid[cell.x()][cell.y() + 1];
        }
        // Add cell to left if it exists
        if (cell.x() - 1 >= 0 && cell.x() - 1 < grid.length)
        {
            cells[3] = grid[cell.x() - 1][cell.y()];
        }

        return cells;
    }


    /**
     * Patches the error in primsAlgorithm() that leaves cells unexplored by
     * brute force, checking for any such cells and destroying all of their
     * walls (except those on the edge of the maze).
     * It also stores the number of cells that were patched in the patched
     * field.
     */
    private void patch()
    {
        for (Cell[] column : grid)
        {
            for (Cell cell : column)
            {
                if (cell.numberOfWalls() == 4)
                {
                    destroyWalls(cell);
                    //patched++;
                }
            }

        }
    }

    /**
     * Destroys all walls of a cell if the cells on the other side of each wall
     * exists.
     * @param Cell The cell whose walls are being destroyed
     */
    private void destroyWalls(Cell cell)
    {
        Cell[] cells = getAdjacentCells(cell);
        for (int i = 0; i < cells.length; i++)
        {
            if (cells[i] != null)
            {
                cell.removeWall(i);
                if (i + 2 < cells.length)
                {
                    cells[i].removeWall(i + 2);
                }
                else
                {
                    cells[i].removeWall(i - 2);
                }
            }
        }
    }

    /**
     * Creates randomized open areas in the maze, taking into account
     * the size of the maze.
     */
    private void openRooms()
    {
        // Create floorSize - 1 rooms
        for (int i = 0; i < (floorSize - 9); i++)
        {
            Cell room = grid[rand.nextInt(grid.length)][rand.nextInt(grid[0].length)];
            Cell[] adjacentCells = getAdjacentCells(room);
            for (Cell cell : adjacentCells)
            {
                if(cell != null)
                {
                    destroyWalls(cell);
                }
            }
        }
    }


    private void placeExit()
    {
        exitX = rand.nextInt(grid.length);
        exitY = 0;
        grid[exitX][exitY].setExit();
    }

    public int exitRow()
    {
        return exitY;
    }

    public int exitColumn()
    {
        return exitX;
    }

    public int startRow()
    {
        return startY;
    }

    public int startColumn()
    {
        return startX;
    }

    /**
     * Randomly places enemies on empty cells based on the floor level.
     */
    private void spawnEnemies()
    {
        // TODO: Determine how may enemies per floor. Right now is just floorsize
        int enemies = 0;
        while (enemies < floorSize)
        {
            //Get a random cell for the enemy to spawn in
            Cell cell = grid[rand.nextInt(grid.length)][rand.nextInt(grid[0].length)];
            //If that cell is either of the start or exit cells, or already has
            //an enemy in it, pick a new cell until it's not
            while ((cell.x() == startX && cell.y() == startY)
                || (cell.x() == exitX && cell.y() == exitY) ||
                cell.getEnemy() != null)
            {
                cell = grid[rand.nextInt(grid.length)][rand.nextInt(grid[0].length)];
            }
            //Store the enemy in the cell
            cell.setEnemy(new Enemy(floor, gameWorld));
            enemies++;
        }
    }

    /**
     * Randomly places items on empty cells (this does not include enemy drops)
     */
    private void placeItems()
    {
        if (startX < grid.length - 1 && grid[startX + 1][startY].getEnemy() == null)
        {
            grid[startX + 1][startY].setItem(new Armor("Chestplate", "Keeps your guts inside your body", 5.0f, gameWorld));
        }
        if (startX > 0 && grid[startX - 1][startY].getEnemy() == null)
        {
            grid[startX - 1][startY].setItem(new Weapon("Sword", "Pointy sticks are fun to swing around", 5.0f, gameWorld));
        }

        // TODO: Determine how may items per floor. Right now is just floorsize/2
        int items = 0;
        while (items < floorSize / 2)
        {
            //Get a random cell for the item to be placed in
            Cell cell = grid[rand.nextInt(grid.length)][rand.nextInt(grid[0].length)];
            //If that cell is either of the start or exit cells,
            //or if there is an enemy or item already there, pick a new cell
            //until a valid empty one is found
            while ((cell.x() == startX && cell.y() == startY)
                || (cell.x() == exitX && cell.y() == exitY)
                || cell.getEnemy() != null || cell.getItem() != null)
            {
                cell = grid[rand.nextInt(grid.length)][rand.nextInt(grid[0].length)];
            }
            //Store a generated item in the cell
            cell.setItem(gameWorld.getItemCreator().selectItem());

            itemlist[items] = cell.getItem().getName() + ", (" + cell.x() + ", " + cell.y() + " )";

            items++;
        }
    }

    // ----------------------------------------------------------
    /**
     * Returns the cell at the specified location.
     *
     * @param x
     *            The x coordinate of the cell
     * @param y
     *            The y coordinate of the cell
     * @return Cell The cell at the given location
     */
    public Cell getCell(int x, int y)
    {
        if (x < grid.length && y < grid[0].length &&
            x >= 0 && y >= 0)
        {
            return grid[x][y];
        }
        else
        {
            return null;
        }
    }


    /**
     * Returns the size of the maze.
     *
     * @return int
     */
    public int floorSize()
    {
        return floorSize;
    }

    /**
     * Returns the floor of the maze.
     * @return The floor of this maze.
     */
    public int getFloor()
    {
        return floor;
    }


    // -------------------------------------------------------------------------
    /**
     * This is a FIFO array-based Queue in which elements are removed in the
     * order that they were added. This is used in the primsAlgorithm() method
     * for keeping track of the order in which cells must be examined for
     * adjacent unexplored cells.
     *
     * @author Petey
     * @version Nov 4, 2012
     */
    private class CellQueue
    {
        private Cell[] cells;
        private int    capacity;
        private int    size;


        /**
         * Creates a new queue of cells of the given capacity.
         *
         * @param capacity
         *            The initial capacity of the queue
         */
        public CellQueue(int capacity)
        {
            cells = new Cell[capacity];
            this.capacity = capacity;
        }


        /**
         * Accessor for the number of elements in the queue.
         *
         * @return int The number of elements
         */
        public int size()
        {
            return size;
        }


        /**
         * Accessor for the capacity of the queue.
         *
         * @return int The capacity
         */
        public int capacity()
        {
            return cells.length;
        }


        /**
         * Add the given cell to the back of the queue.
         *
         * @param cell
         *            The cell to be appended to the queue
         */
        public void enqueue(Cell cell)
        {
            if (size == capacity)
            {
                expandCapacity();
            }
            cells[size] = cell;
            size++;
        }


        /**
         * Doubles the capacity of the queue.
         */
        private void expandCapacity()
        {
            capacity *= 2;
            Cell[] array = new Cell[capacity];
            System.arraycopy(cells, 0, array, 0, size);
            cells = array;
        }


        /**
         * Remove the first cell in the queue.
         */
        public void dequeue()
        {
            if (size > 0)
            {
                Cell[] array = new Cell[cells.length - 1];
                System.arraycopy(cells, 1, array, 0, size - 1);
                cells = array;
                capacity -= 1;
                size--;
            }
            else
            {
                return;
            }
        }


        /**
         * Accessor for the first cell in the queue.
         *
         * @return Cell The first cell
         */
        public Cell front()
        {
            return cells[0];
        }


        /**
         * Determines whether the queue contains any cells.
         *
         * @return Whether the queue is empty
         */
        public boolean isEmpty()
        {
            return size == 0;
        }

    }

}
